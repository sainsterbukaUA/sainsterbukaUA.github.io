<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.14">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Rizqy Amelia Zein">
<meta name="dcterms.date" content="2019-11-05">

<title>Bias Publikasi dan Preprint – Airlangga Open Science</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-8f1af79587c2686b78fe4e1fbadd71ab.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-22c6e3231a5e8c2570b1fc07b7302227.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">


<link rel="stylesheet" href="../styles.css">
</head>

<body class="fullcontent quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Bias Publikasi dan Preprint</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Rizqy Amelia Zein </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">11/05/2019</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>#SainsTerbuka Airlangga secara reguler memposting informasi yang berkaitan dengan #SainsTerbuka dan dua minggu yang lalu kami memposting dua utas, yaitu tentan <em>bias publikasi</em> dan <em>pre-print</em>. Berikut adalah arsip dari kedua utas tersebut.</p>
<section id="bias-publikasi" class="level2">
<h2 class="anchored" data-anchor-id="bias-publikasi"><a href="https://twitter.com/sainsterbukaUA/status/1123723896384118784">Bias Publikasi</a></h2>
<p>Selamat pagi kawan2 semua! Pagi ini kami akan share informasi ttg file drawer dan publication bias. Sebelumnya mari kita perhatikan sama2 infografis dibawah ini [UTAS]. 1/n</p>
<p>Versi TL;DR — https://web.ma.utexas.edu/users/mks/statmistakes/filedrawer.html</p>
<p>Berdasarkan infografis diatas, nyaris semua studi yg dipublikasikan di jurnal ilmiah, terlalu banyak memajang temuan penelitian yg positif (signifikan scr statistik - kalau pakai pendekatan null hypothesis significant testing (NHST)). 2/n</p>
<p>Apakah ini hal yang baik? Tentu tidak :) ini menunjukkan kegagalan saintis utk melakukan falsifikasi. Ingat, self correction dalam sains sama pentingnya dg discovery/inovasi. 3/n</p>
<p>Sehingga ini menunjukkan kondisi yg too good to be true. Ada yg salah disini. Sangat mungkin hasil negatif (yg tidak signifikan) tidak banyak mendapat tempat di outlet tradisional spt jurnal ilmiah. 4/n</p>
<p>Fenomena ini disebut juga dg file drawer effect, yaitu temuan negatif akan cenderung ‘disembunyikan’ didalam lemari, tdk dipublikasikan. Kenapa? Krn editor, reviewer dan pembimbing TA anda ga happy dg hasil negatif kan? :) 5/n</p>
<p>Mengapa ini berbahaya bagi perkembangan sains? Dalam penelitian kumulatif seperti meta-analisis, hasil negatif diperlukan utk mengestimasi secara akurat agregat ukuran efek (pooled effect size). Kalo yg existing findings kebanyakan positif, maka yg tjd adlh publication bias. 6/n</p>
<p>Artinya, penelitian2 yg dipublikasi kemungkinan bsr melebih2kan (overestimasi) ukuran efek yg mereka temukan. Akhirnya false positive rate (peluang tjdnya type 1 error - peneliti bilang ada efek/hubungan/pengaruh, tapi sbnrnya ga ada) menjadi semakin tak terkendali… 7/n</p>
<p>Sehingga penelitian yg terpublikasi justru memberikan inferensi/pengambilan kesimpulan yg ‘berisiko menyesatkan’. Lalu bagaimana mengatasinya? 8/n</p>
<p>Scr statistik ada teknik yg bisa digunakan utk ‘mengkoreksi’ bias publikasi, salah satunya adalah trim-and-fill. Tapi belakangan diketahui bahwa teknik2 ini ternyata memberikan informasi yg tidak konsisten (tdk robust). 9/n</p>
<p>Selain itu, pre-print server punya peran penting utk menerbitkan hasil2 negatif ini. Soalnya tdk semua jurnal mau menerbitkan hasil negatif. Jadi pre-print server spt <span class="citation" data-cites="INArxiv_ID">@INArxiv_ID</span> amat penting perannya dlm mengkoreksi sains :) 10/n</p>
<p>Cara lain yg amat kami sarankan adalah pra-registrasikan studi anda! :) atau pertimbangkan utk membuat laporan dlm bentuk registered report (RR). Dg begitu, jurnal akan tetap mau mempublikasikan hasil studi yg negatif. 11/n</p>
<p>Apa itu RR dan pre-reg? Nanti kita bahas di utas berikutnya :) 12/12</p>
</section>
<section id="pre-print" class="level2">
<h2 class="anchored" data-anchor-id="pre-print"><a href="https://twitter.com/sainsterbukaUA/status/1124611179639238656">Pre-Print</a></h2>
<p>Ada yg pernah dengar istilah pre-print? Yup, pre-print sedang populer saat ini. Pre-print adalah inovasi dlm komunikasi sains yg menambal bbrp kelemahan outlet penerbitan ilmiah tradisional. [UTAS] 1/n</p>
<p>Apa itu pre-print (PP)? PP adalah manuskrip yg belum sama sekali tersentuh proses editorial jurnal. Ia belum disubmit dan belum tersentuh proses peer-review. 2/</p>
<p>Sedangkan PP Server adalah halaman web yg menjadi ‘rumah’ dari PP. Saat ini PP Server sdh ckp banyak dan beragam. Salah satunya adalah <span class="citation" data-cites="INArxiv_ID">@INArxiv_ID</span>. RG juga bisa, pakai repo kampus juga bisa. 3/</p>
<p>Biasanya versi pertama dari naskah ini disimpan rapat2 oleh penulis. Tak jarang penulis menolak membagikan draft pertamanya dg alasan sedang/akan direview oleh jurnal. Padahal PP banyak manfaatnya. 4/</p>
<ol type="1">
<li>Waktu. Menerbitkan manuskrip di jurnal butuh waktu yang lama (~1-3 tahun), padahal sangat mungkin diluar sana ada peneliti/pihak lain yg sangat membutuhkan hasil penelitian anda. Klo tunggu terbit, sangat mungkin naskah tsb jadi berkurang relevansinya. 5/</li>
</ol>
<p>Lho bgmn klo ide dlm naskah anda dicuri orang lain? Hehehe ini alasan yg kurang tepat. Justru mempublikasikan karya anda sesegera mungkin, anda bisa melindungi ide anda dari awal. Gmn mungkin anda bisa mengklaim ide tsb milik anda, tanpa punya bukti yg ‘disaksikan’ o/publik? 6/</p>
<p>PP Server biasanya menerapkan proses moderasi yg ckp singkat. PP Server punya SAGE dan PLoS misalnya, sdh bisa menampilkan naskah dg tempo moderasi 24-48 jam. 7/</p>
<p>Sedangkan <span class="citation" data-cites="INArxiv_ID">@INArxiv_ID</span> menerapkan post-moderation. Artinya, administrator tdk akan memoderasi naskah, sehingga naskah langsung ditampilkan segera setelah diunggah. Tetapi naskah dpt di takedown kalau dianggap melanggar T&amp;R. 8/</p>
<ol start="2" type="1">
<li><p>Kolaborasi. Dg melakukan timely publication atas karya kita. Kesempatan mendapatkan kolaborasi riset akan terbuka luas dg lebih cepat. Bayangkan kalo kita harus menunggu 2-3 tahun sampai punya naskah yg sdh diterbitkan. 9/</p></li>
<li><p>Pengakuan. Jgn takut ide anda dicuri dg mengunggah naskah ke PP Server. Semua naskah yg diunggah ke PP Server akan mendapatkan ‘stempel’ berupa DOI. Dg begitu anda bisa menggunakannya utk mengklaim hasil penelitian anda. 10/</p></li>
<li><p>Umpan Balik. Dengan mengunggah PP maka anda bisa mendapatkan umpan balik dari orang lain atas karya anda, bahkan sblm naskah tsb direview di jurnal. Dg begitu anda dpt meningkatkan kualitas naskah anda. 11/</p></li>
<li><p>Pendanaan Penelitian. Anda bisa menggunakan PP sbg bukti luaran. Sayangnya Kementerian msh beda frekuensi dg #OpenScience. Ya selamat.. silahkan tunggu 2-3 tahun sampe bisa melaporkan bahwa penelitian anda ‘ada hasilnya’. 12/</p></li>
</ol>
<p>Padahal sudah ada banyak pendana yg mengubah kebijakannya dg menyarankan peneliti mengunggah PP atas hasil penelitian yg mrk biayai. Berikut adlh pendana2 tsb https://asapbio.org/funder-policies 13/</p>
<p>Revisi utk tweet (8). <span class="citation" data-cites="INArxiv_ID">@INArxiv_ID</span> tetap melakukan moderasi (bkn tdk memoderasi), namun dilakukan ketika naskah sudah diunggah dan diterbitkan. Selanjutnya, akan kami lanjutkan stlh maghrib.. :)</p>
<ol start="6" type="1">
<li><p>Inklusif. PP menyediakan tempat bagi naskah yg sulit dapat tempat di outlet tradisional. Misalnya, penelitian dg hasil yg negatif dan hasil replikasi. Ini penting bagi kemajuan sains. Sila mampir ke utas kami sebelumnya. 14/</p></li>
<li><p>Akses Terbuka. Siapa yg ‘rela’ bayar $20 utk baca satu artikel (yg belum tentu relevan dg kebutuhan kita)? Sdh banyak kritik pada penerbit (hiper)komersial krn menjalankan model bisnis yg eksploitatif… 15/</p></li>
</ol>
<p>Dengan mengunggah PP, setidaknya pembaca punya alternatif akses thd karya anda, sehingga pembaca tdk terlalu bergantung pd jasa yg disediakan o/ penerbit komersial. Anda bahkan sebenarnya bisa mengunggah post-print (PoP)… 16/</p>
<p>Yaitu naskah yg sudah selesai direview, tapi blm dipegang oleh in-house copyeditor dan belum di layout oleh penerbit. Ketika karya anda sdh terbit di jurnal, PP Server juga menyediakan fitur dimana anda… 17/</p>
<p>Bisa mentautkan naskah yg sudah published di jurnal pada naskah PP anda. Sehingga pembaca bisa membandingkan kondisi naskah sebelum dg sesudah direview 18/</p>
<p>PP Server tertentu juga menyediakan fitur yg memungkinkan anda mentautkan PP dg repositori tempat anda menyimpan raw data, script analisis dan semua material studi. 19/</p>
<p>Dengan begitu, sebagai seorang peneliti, anda bersedia bertanggungjawab secara publik atas karya anda. Anda juga memungkinkan peneliti lain mereproduksi hasil studi anda. 20/</p>
<p>Akhirnya, inovasi dan ide2 baru akan muncul. Kolaborasi dan jejaring juga akan terbentuk. Inovasi dan self-correction sama2 berjalan. Idealnya, begitulan seharusnya sains dikelola. 21/21</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>